import socket
import struct
import cv2
import numpy as np
import time
from ultralytics import YOLO
model = YOLO("yolov8n.pt")  # Ho·∫∑c model custom n·∫øu b·∫°n c√≥
import torch
print(torch.version.cuda)
from deep_sort_realtime.deepsort_tracker import DeepSort
tracker = DeepSort(max_age=30)  # max_age gi√∫p gi·ªØ ID khi m·∫•t t·∫°m th·ªùi


# C·∫•u h√¨nh
HOST        = "0.0.0.0"
PORT        = 9999
RECV_TIMEOUT= 5.0    # gi√¢y ch·ªù gi·ªØa c√°c recv
WARMUP_FRAMES = 5    # s·ªë frame ƒë·∫ßu ch·ªâ ƒë·ªçc m√† kh√¥ng hi·ªÉn th·ªã

def receive_all(sock, size):
    """Nh·∫≠n ƒë√∫ng 'size' byte; raise ConnectionError n·∫øu timeout ho·∫∑c socket ƒë√≥ng."""
    data = b''
    start = time.time()
    while len(data) < size:
        if time.time() - start > RECV_TIMEOUT:
            raise ConnectionError("‚ö†Ô∏è Timeout khi recv d·ªØ li·ªáu")
        try:
            packet = sock.recv(size - len(data))
        except socket.timeout:
            raise ConnectionError("‚ö†Ô∏è Timeout khi recv d·ªØ li·ªáu")
        if not packet:
            raise ConnectionError("‚ö†Ô∏è Socket ƒë√£ ƒë√≥ng")
        data += packet
    return data

def handle_client(client, addr, cam_id):
    print(f"‚úÖ Camera-{cam_id} ƒë√£ k·∫øt n·ªëi t·ª´ {addr}")
    client.settimeout(RECV_TIMEOUT)
    window_name = f"Camera-{cam_id}"

    for i in range(WARMUP_FRAMES):
        raw_len = receive_all(client, 4)
        img_len = struct.unpack('<I', raw_len)[0]
        _ = receive_all(client, img_len)
        _ = receive_all(client, 4)
        print(f"üîß Camera-{cam_id} Warm-up frame {i+1}/{WARMUP_FRAMES}")

    print(f"üé¨ Camera-{cam_id} b·∫Øt ƒë·∫ßu hi·ªÉn th·ªã ·∫£nh")
    frame_count = 0
    start_time = time.time()

    try:
        while True:
            raw_len = receive_all(client, 4)
            img_len = struct.unpack('<I', raw_len)[0]
            img_data = receive_all(client, img_len)
            raw_ck = receive_all(client, 4)
            recv_ck = struct.unpack('<I', raw_ck)[0]
            calc_ck = sum(img_data)
            if recv_ck != calc_ck:
                print("‚ùå Checksum l·ªói ‚Äì b·ªè frame")
                continue

            img = cv2.imdecode(np.frombuffer(img_data, dtype=np.uint8), cv2.IMREAD_COLOR)
            if img is not None:
                # üëâ YOLO detect
                results = model(img, verbose=False)[0]
                detections = []

                if results.boxes is not None:
                    for box, cls in zip(results.boxes.xyxy, results.boxes.cls):
                        x1, y1, x2, y2 = map(int, box[:4])
                        conf = float(box[4]) if len(box) > 4 else 0.0
                        cls_name = model.names[int(cls)]
                        detections.append(([x1, y1, x2 - x1, y2 - y1], conf, cls_name))

                # üëâ Tracking
                tracks = tracker.update_tracks(detections, frame=img)

                for track in tracks:
                    if not track.is_confirmed():
                        continue
                    track_id = track.track_id
                    l, t, w, h = track.to_ltrb()
                    x1, y1, x2, y2 = int(l), int(t), int(l + w), int(t + h)
                    cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
                    cv2.putText(img, f"ID {track_id}", (x1, y1 - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)

                cv2.imshow(window_name, img)
                frame_count += 1

            if cv2.waitKey(1) == 27:
                print("‚õî Nh·∫•n ESC, d·ª´ng client")
                break

    except ConnectionError as e:
        print(f"‚ö†Ô∏è Camera-{cam_id} m·∫•t k·∫øt n·ªëi:", e)
    finally:
        elapsed = time.time() - start_time
        fps = frame_count / elapsed if elapsed > 0 else 0
        print(f"üîí ƒê√≥ng k·∫øt n·ªëi Camera-{cam_id}. Frames: {frame_count}, FPS: {fps:.2f}\n")
        client.close()
        cv2.destroyAllWindows()


def run_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((HOST, PORT))
    server.listen(1)
    print(f"üü¢ Server ch·∫°y tr√™n {HOST}:{PORT}")

    try:
        while True:
            print("üîÑ Ch·ªù ESP32 k·∫øt n·ªëi l·∫°i...")
            client, addr = server.accept()

            try:
                id_byte = client.recv(1)
                if not id_byte:
                    print(f"‚ùå Client {addr} kh√¥ng g·ª≠i ID")
                    client.close()
                    continue

                cam_id = id_byte[0]
                print(f"üÜî ESP32 Camera-{cam_id} ƒë√£ k·∫øt n·ªëi t·ª´ {addr}")
                
                handle_client(client, addr, cam_id)

            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi nh·∫≠n ID t·ª´ {addr}: {e}")
                client.close()

    except KeyboardInterrupt:
        print("‚úã Server d·ª´ng th·ªß c√¥ng")
    finally:
        server.close()
        cv2.destroyAllWindows()

if __name__ == "__main__":
    run_server()
